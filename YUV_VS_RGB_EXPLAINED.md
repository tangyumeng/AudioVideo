# YUV vs RGB 深度解析

## 🤔 为什么说"YUV更接近人眼感知"？

### 人眼视觉系统的秘密

人类的视觉系统是经过数百万年进化而来的，具有以下特点：

#### 1. 视杆细胞 vs 视锥细胞

人眼视网膜上有两种光感受器：

**视杆细胞（Rods）**:
- 数量：约1.2亿个
- 作用：感知亮度（明暗）
- 特点：高度敏感，负责夜视和周边视觉

**视锥细胞（Cones）**:
- 数量：约600万个
- 作用：感知颜色
- 特点：需要较强光线，分三种（红、绿、蓝）

**关键发现**：视杆细胞是视锥细胞的**20倍**！

#### 2. 敏感度差异

```
对亮度变化的敏感度：  ████████████████████ 100%
对色度变化的敏感度：  ████████░░░░░░░░░░░░  40%
```

这意味着：
- 我们能轻易察觉亮度的细微变化
- 但对色彩的细节变化不太敏感

#### 3. 实际例子

看这两张图片：

**场景A：高对比度黑白照片**
- 能清晰看到所有细节
- 人物轮廓、纹理、表情都很清楚
- 即使没有颜色，信息量依然很大

**场景B：低对比度彩色照片**
- 细节模糊不清
- 即使有丰富的颜色，信息量也很少
- 难以识别物体

**结论**：亮度信息比色彩信息更重要！

---

## 📊 RGB vs YUV 对比

### RGB 颜色空间

```
像素 = (R, G, B)

例如：白色 = (255, 255, 255)
     黑色 = (0, 0, 0)
     红色 = (255, 0, 0)
```

**特点**：
- ✅ 直观，容易理解
- ✅ 显示器天然支持
- ✅ 简单的加法混色
- ❌ 亮度和色彩耦合在一起
- ❌ 无法单独调整亮度
- ❌ 不符合人眼感知特性

**问题**：
三个通道同等重要，但人眼对它们的敏感度并不相同！

### YUV 颜色空间

```
Y  = 亮度 (Luminance)
U  = 色度蓝 (Cb - Chroma Blue)
V  = 色度红 (Cr - Chroma Red)
```

**转换公式**（从RGB到YUV）：

```
Y = 0.299R + 0.587G + 0.114B
U = -0.147R - 0.289G + 0.436B
V = 0.615R - 0.515G - 0.100B
```

注意系数：
- **Y通道**：绿色占比最大（0.587），因为人眼对绿色最敏感
- **U和V通道**：只记录色彩差异

**特点**：
- ✅ 亮度和色彩分离
- ✅ 符合人眼感知
- ✅ 便于压缩（色度可以降采样）
- ✅ 可以单独调整亮度/对比度
- ❌ 需要转换才能显示

---

## 🎯 为什么说YUV"更接近人眼感知"？

### 1. 亮度色度分离

**YUV**:
```
Y ────→ 完整的亮度信息（细节、边缘、纹理）
U ────→ 色度信息（蓝色分量）
V ────→ 色度信息（红色分量）
```

**优势**：
- 可以看黑白的Y通道，依然能看清所有细节
- U和V只是"给Y上色"

**RGB**:
```
R ────→ 红色分量（包含部分亮度）
G ────→ 绿色分量（包含部分亮度）
B ────→ 蓝色分量（包含部分亮度）
```

**问题**：
- 单独看R、G或B任何一个通道，都无法得到完整图像
- 亮度信息分散在三个通道中

### 2. 色度降采样（Chroma Subsampling）

基于"人眼对色度不敏感"，YUV可以：

#### YUV 4:4:4（无降采样）
```
Y: ████████████████
U: ████████████████
V: ████████████████

每个像素都有完整的Y、U、V
内存占用：3 bytes/pixel
```

#### YUV 4:2:0（最常用）
```
Y: ████████████████  (全分辨率)
U: ████░░░░████░░░░  (1/2宽度 × 1/2高度)
V: ████░░░░████░░░░  (1/2宽度 × 1/2高度)

4个Y像素共享1组UV
内存占用：1.5 bytes/pixel (节省50%！)
```

**神奇之处**：
- 色度信息减少了75%
- 但人眼几乎**看不出区别**！
- 这就是"更接近人眼感知"的体现

### 3. 实际效果对比

#### 测试：压缩色度信息

**原图**：YUV 4:4:4
- Y: 1920×1080 = 2,073,600 像素
- U: 1920×1080 = 2,073,600 像素
- V: 1920×1080 = 2,073,600 像素
- 总计：6,220,800 bytes ≈ 6MB

**压缩后**：YUV 4:2:0
- Y: 1920×1080 = 2,073,600 像素
- U: 960×540 = 518,400 像素
- V: 960×540 = 518,400 像素
- 总计：3,110,400 bytes ≈ 3MB

**结果**：
- 文件大小减半
- 视觉质量几乎无损
- 如果用RGB，无法这样压缩（会严重损失质量）

---

## 💡 为什么视频使用YUV？

### 1. 大幅节省带宽

以1080p 30fps视频为例：

**如果用RGB**:
```
1920 × 1080 × 3 bytes × 30 fps = 186 MB/s
```

**如果用YUV 4:2:0**:
```
1920 × 1080 × 1.5 bytes × 30 fps = 93 MB/s

节省 50%！
```

### 2. 更高效的编码

**H.264/H.265编码器**：
- 可以对Y通道使用更高质量编码（保留细节）
- 对UV通道使用更激进的压缩（节省空间）
- 最终达到视觉质量和文件大小的平衡

**如果用RGB**：
- 无法区分重要信息和不重要信息
- 要么全部高质量（文件太大）
- 要么全部低质量（画面太差）

### 3. 历史原因

YUV最初是为**黑白电视到彩色电视**的过渡设计的：

```
旧的黑白电视 ────→ 只接收Y信号
新的彩色电视 ────→ 接收Y + U + V信号
```

这样黑白电视和彩色电视可以兼容！

---

## 🔬 深入理解：代码示例

### 从RGB转YUV

```swift
func convertRGBtoYUV(r: UInt8, g: UInt8, b: UInt8) -> (y: UInt8, u: UInt8, v: UInt8) {
    let rf = Float(r)
    let gf = Float(g)
    let bf = Float(b)
    
    // Y通道：亮度（注意绿色权重最大）
    let y = 0.299 * rf + 0.587 * gf + 0.114 * bf
    
    // U通道：蓝色色度
    let u = -0.147 * rf - 0.289 * gf + 0.436 * bf + 128
    
    // V通道：红色色度
    let v = 0.615 * rf - 0.515 * gf - 0.100 * bf + 128
    
    return (
        y: UInt8(max(0, min(255, y))),
        u: UInt8(max(0, min(255, u))),
        v: UInt8(max(0, min(255, v)))
    )
}
```

### 为什么绿色权重最大？

```
Y = 0.299R + 0.587G + 0.114B
         ↑        ↑        ↑
       30%      59%      11%
```

**原因**：
1. 人眼对绿光最敏感（555nm波长）
2. 自然界中绿色最丰富（植物）
3. 进化使我们对绿色特别敏感

### 可视化示例

假设一个纯红色像素：`RGB(255, 0, 0)`

```swift
// 转换为YUV
Y = 0.299 × 255 = 76.2    // 亮度：30%
U = -0.147 × 255 + 128 = 90.5
V = 0.615 × 255 + 128 = 284.8 → 255 (截断)

// 结果：YUV(76, 91, 255)
```

**观察**：
- Y值只有76（满分255），因为纯红色在人眼看来并不很亮
- 如果是白色 RGB(255, 255, 255)，Y值会是255（最亮）

---

## 📊 不同YUV采样格式

### YUV 4:4:4
```
像素排列：
Y Y Y Y     U U U U     V V V V
Y Y Y Y     U U U U     V V V V
Y Y Y Y     U U U U     V V V V
Y Y Y Y     U U U U     V V V V

每个像素独立的YUV值
```

### YUV 4:2:2
```
像素排列：
Y Y Y Y     U   U       V   V
Y Y Y Y     U   U       V   V
Y Y Y Y     U   U       V   V
Y Y Y Y     U   U       V   V

U和V水平方向减半
```

### YUV 4:2:0（最常用）
```
像素排列：
Y Y Y Y     U           V
Y Y Y Y    
Y Y Y Y     U           V
Y Y Y Y    

U和V水平和垂直都减半
4个Y像素共享1个U和1个V
```

---

## 🎬 在iOS中的应用

### 1. 相机采集

```swift
let videoOutput = AVCaptureVideoDataOutput()

// 选择YUV格式（推荐）
videoOutput.videoSettings = [
    kCVPixelBufferPixelFormatTypeKey as String: 
        kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange  // NV12格式
]

// vs

// 选择RGB格式
videoOutput.videoSettings = [
    kCVPixelBufferPixelFormatTypeKey as String: 
        kCVPixelFormatType_32BGRA  // BGRA格式
]
```

**何时用YUV**：
- ✅ 需要录制视频
- ✅ 需要实时编码
- ✅ 需要传输到服务器
- ✅ 性能要求高

**何时用RGB**：
- ✅ 需要实时显示
- ✅ 需要像素级处理
- ✅ 需要使用Core Image
- ✅ 需要精确的颜色控制

### 2. H.264编码

VideoToolbox编码器**只接受YUV**输入：

```swift
// ✅ 正确：YUV输入
VTCompressionSessionCreate(
    // ...
    sourcePixelBufferAttributes: [
        kCVPixelBufferPixelFormatTypeKey: 
            kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange
    ]
)

// ❌ 错误：RGB需要先转换
// 编码器会拒绝或自动转换（性能损失）
```

### 3. 内存占用对比

以720p视频为例：

```
RGB (BGRA):
1280 × 720 × 4 = 3,686,400 bytes ≈ 3.5 MB/帧

YUV 4:2:0:
1280 × 720 × 1.5 = 1,382,400 bytes ≈ 1.3 MB/帧

节省：2.3 MB/帧
30fps视频每秒节省：69 MB！
```

---

## 🎓 总结

### YUV更接近人眼感知的原因

1. **亮度色度分离**：
   - Y通道：完整细节（人眼敏感）
   - UV通道：色彩信息（人眼不敏感）

2. **允许色度降采样**：
   - 减少75%色度数据
   - 视觉质量几乎无损
   - RGB无法这样做

3. **符合人眼特性**：
   - 视杆细胞（亮度）20×视锥细胞（颜色）
   - 对亮度敏感度是色度的2-4倍
   - YUV正是基于这一特性设计

### 快速记忆

```
RGB = 三个通道同等重要 = 不符合人眼
YUV = 亮度重要，色度次要 = 符合人眼 ✓
```

### 实际应用

```
相机采集 ─→ YUV 4:2:0 ─→ 节省内存
    ↓
视频编码 ─→ H.264/H.265 ─→ 高效压缩
    ↓
视频传输 ─→ 带宽减半 ─→ 流畅播放
    ↓
视频解码 ─→ YUV 4:2:0 ─→ 快速解码
    ↓
显示转换 ─→ YUV→RGB ─→ 屏幕显示
```

---

## 📚 扩展阅读

1. **Rec.601 / Rec.709**: 不同的YUV转换标准
2. **BT.2020**: 4K/8K视频的颜色空间
3. **Y'CbCr vs YUV**: 数字vs模拟
4. **色度插值算法**: 如何从4:2:0还原到4:4:4

---

**记住**：YUV不是为了数学上的完美，而是为了**匹配人眼的感知方式**！ 👁️✨

